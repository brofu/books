# Definition
**装饰者模式**动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案

# OO原则
* 对扩展开放，对修改关闭
  * 隔离关闭的部分和新扩展的部分

# Thinkings
* **装饰者模式**的缺点
  * 设计中被引入大量的小类。比如 Java I/O库
  * 客户端程序依赖组件的具体类型（而非抽象类型）
    * 装饰者一般对组件的客户端是透明的，除非客户端程序依赖于组件的具体类型
    * 装饰者类反映出被撞使者的组件类型
  * 实例化组件时，代码复杂度增加。（不仅需要实例化组件，还需要讲组件层层包装进装饰者）
    * 解决办法 factory pattern & builder pattern
  * 遵循开发-关闭远程原则，通常会引入新的抽象层次。
* 关于扩展和修改。
  * 除了继承，装饰者模式也可以扩展行为
  * 设计中，应该允许行为可以被扩展，而无须修改现有的代码
  * 组合和委托(delegation) 可用于在运行时动态的扩展新的行为
  * 选择需要被扩展的代码部分时要小心。每个地方都采取开房-封闭原则，是一种浪费，也没有必要
